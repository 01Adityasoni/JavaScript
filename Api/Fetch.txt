Big picture (remember this first)

fetch() works in TWO BIG PHASES:

Promise creation phase (JavaScript side)

Network request phase (Browser side)

JavaScript does NOT do the network request itself.
The browser does it.

Simple fetch code
fetch("https://api.example.com/data")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.log(error));


Now letâ€™s break everything step by step ğŸ‘‡

ğŸ§  STEP 1: JavaScript runs fetch()
Call Stack
fetch("url")


JS engine (V8) sees fetch

fetch is a Web API, not pure JS

JS sends this work to the browser

âœ… Immediately returns a Promise

Promise { <pending> }


ğŸ“Œ Important

fetch() does NOT block
It returns a Promise instantly

ğŸ§  STEP 2: Promise object is created (VERY IMPORTANT)

When fetch() is called:

Promise is created with:
- state: pending
- result: undefined


Internally, browser prepares TWO internal lists (arrays):

Internal promise reactions (not real arrays, but conceptually)
Fulfillment handlers list â†’ .then()
Rejection handlers list   â†’ .catch()


So when you write:

.then(...)
.catch(...)


JS is doing this:

onFulfilled[] = [then callbacks]
onRejected[]  = [catch callbacks]


âš ï¸ Nothing runs yet.

ğŸŒ STEP 3: Browser starts NETWORK REQUEST

Now browser takes over:

Browser components involved

Network thread

DNS

TCP

HTTP

Browser does:

DNS lookup

TCP connection

Send HTTP request

Wait for response

â³ This can take 1 sec, 5 sec, or more

Meanwhileâ€¦

ğŸ§  STEP 4: Event Loop keeps running

JavaScript is free now.

Event loop continues handling:

Call stack

Microtask queue

Task queue

âŒ fetch is NOT blocking anything.

ğŸŒ STEP 5: Network response arrives

Now two cases happen ğŸ‘‡

âœ… CASE 1: Request SUCCESS (HTTP response received)

Browser does NOT put data directly into JS.

Instead:

Promise state changes:

pending â†’ fulfilled


Response object is created:

Response { body, headers, status, ok }


.then() callbacks are queued into:

MICROTASK QUEUE


ğŸ“Œ Because Promise callbacks always go to microtask queue

âŒ CASE 2: Request FAILURE (network error)

Example:

No internet

DNS fail

CORS error

Browser does:

pending â†’ rejected


.catch() callbacks go to:

MICROTASK QUEUE

ğŸ” STEP 6: Event Loop executes microtasks

Event loop rule:

After call stack is empty â†’ run ALL microtasks

So:

Call Stack empty
â†“
Microtask Queue runs
â†“
.then() or .catch() executes

ğŸ” STEP 7: response.json() (SECOND ASYNC STEP)

Very important point â—
This confuses many people.

response.json()

What happens?

Response body is a stream

Parsing JSON takes time

So response.json() also returns a Promise

Again:

pending â†’ fulfilled / rejected


Again:

.then() goes to microtask queue

So fetch has TWO async layers:

Network request

Body parsing

ğŸ” FULL FLOW (SHORT VERSION)
fetch()
â†“
Promise created (pending)
â†“
Browser starts network request
â†“
JS keeps running
â†“
Network response arrives
â†“
Promise fulfilled / rejected
â†“
.then / .catch â†’ microtask queue
â†“
Event loop executes microtasks
â†“
response.json() â†’ new Promise
â†“
Final data available

ğŸ“Š Visual mental model
JS Call Stack
    |
    v
fetch() â”€â”€â–¶ Browser Network
    |
    v
Promise (pending)
    |
    v
Network done
    |
    v
Microtask Queue (.then / .catch)
    |
    v
Call Stack

âš ï¸ VERY IMPORTANT INTERVIEW POINT

âŒ fetch() reject does NOT mean HTTP error
âœ… fetch() reject means network error

Example:

fetch("url")

Status	Promise
200	fulfilled
404	fulfilled
500	fulfilled
No internet	rejected

You must check:

if (!response.ok) throw error;

âœ… Simple final summary

fetch() returns a Promise immediately

Browser handles network

Promise has fulfilled & rejected handlers

.then() / .catch() go to microtask queue

Event loop executes microtasks after call stack

response.json() is another Promise