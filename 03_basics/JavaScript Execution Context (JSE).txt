javascript execution context
There are 3 types of execution context in JavaScript:

1. Global Execution Context (GEC)
2. Functional Execution Context (FEC)
3. Eval Execution Context (EEC) // this is rarely used

PHASES OF EXECUTION 



1. {} memory creation phase or creation phase , in this phase memory allocation is done for variable and functions 
2. Execution phase . all the execution is done in this phase sum , multi , divide , print . all the execution 


let val1 = 10; 
let val2 = 5
function addNum(num1 , num2){
    let total = num1+num2
    return total
}
let result1 = addNum(val1,val2)
let result2 = addNum(10,2)


step 1. global execution or global environment and it is allocated to "this"
step 2. memory phase all the variables are combine together and allocated some memory

for exp -- 
val1 -> undefined
val2 -> undefined
addNum ->Defination of function 
result1 -> undefined
result2 -> undefined

step 3. execution phase 

for exp ->
val1 = 10;
val2 = 5;
addNum -> for this the new variable env and new execution thread is created it is created for all functions then again memory phase and execution phase takes place and once the work of this execution contextis completed the it will deleted automatically  
memory phase -> 
val1 = undefined
val2 = undefined
total = undefined
execution phase -> 
num1 = 10;
num2 = 5;
total =  num1+num2 = 15

then the total return to the parent executional context or global executional context 
now 
result1 = 15;
result2 = again new environment and executional thread is created then again memory phase and executional phase takes place and the it gives the result 







â­ JavaScript Execution Context

There are 3 types:

Global Execution Context (GEC)

Function Execution Context (FEC)

Eval Execution Context (EEC) (rarely used)

â­ Phases of execution
ğŸ”¹ 1. Memory Creation Phase (a.k.a Creation / Hoisting phase)

Memory is allocated for variables and functions.

var â†’ initialized as undefined

let / const â†’ allocated space but not initialized (Temporal Dead Zone)

ğŸ”¹ 2. Execution Phase

Code runs line-by-line

Assignments happen

Functions get called

Calculations happen

â­ Example Program (Your code)
let val1 = 10;
let val2 = 5;

function addNum(num1, num2) {
  let total = num1 + num2;
  return total;
}

let result1 = addNum(val1, val2);
let result2 = addNum(10, 2);

â­ Execution steps â€” Explained cleanly
ğŸ”¸ Step 1: Global Execution Context created

It is linked to this

ğŸ”¸ Step 2: Memory Phase

Memory is allocated:

val1 -> undefined
val2 -> undefined
addNum -> function definition stored
result1 -> undefined
result2 -> undefined

ğŸ”¸ Step 3: Execution Phase

Now real values assigned:

val1 = 10
val2 = 5


Then:

result1 = addNum(val1, val2)

ğŸ”¥ This creates a new function Execution Context

Inside it:

Memory Phase:
num1 -> undefined
num2 -> undefined
total -> undefined

Execution Phase:
num1 = 10
num2 = 5
total = 15


Then return 15 to the parent context â†’ stored in result1

Same happens for result2:
result2 = 12


Because new execution context is created again.

âœ” Final Summary

Yes, your explanation is logically correct.

You understood:

âœ” Global context
âœ” Function context creation
âœ” Memory + Execution phases
âœ” Context deletion
âœ” Return value behavior

Everything matches how JavaScript actually runs ğŸ‘

            
